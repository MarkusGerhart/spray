/*
 * generated by Xtext
 */
package org.xspray.xtext.scoping;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.scoping.impl.FilteringScope;
import org.eclipse.xtext.scoping.impl.MapBasedScope;
import org.xspray.mm.xspray.MetaAttribute;
import org.xspray.mm.xspray.MetaAttributePathSegment;
import org.xspray.mm.xspray.MetaClass;
import org.xspray.mm.xspray.Text;
import org.xspray.mm.xspray.XsprayPackage;

import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;

import static org.xspray.mm.xspray.XsprayPackage.Literals.*;
/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping on
 * how and when to use it
 * 
 */
public class XsprayScopeProvider extends AbstractDeclarativeScopeProvider {
	@Override
	public IScope getScope(EObject context, EReference reference) {
		if (reference == XsprayPackage.Literals.META_CLASS__TYPE) {
			// filter out types with URL schema qualified names
			final IScope scope = delegateGetScope(context, reference);
			final Predicate<IEObjectDescription> filter = new Predicate<IEObjectDescription>() {
				@Override
				public boolean apply(IEObjectDescription input) {
					return !input.getQualifiedName().toString().startsWith("http://");
				}
			};
			return new FilteringScope(scope, filter);
		}
		else if (context.eClass() == META_ATTRIBUTE_PATH_SEGMENT && reference == META_ATTRIBUTE_PATH_SEGMENT__REF) {
			MetaAttribute attr = (MetaAttribute) context.eContainer();
			int i = attr.getPathsegmentsList().indexOf(context);
			if (i>0) {
				MetaAttributePathSegment previousSegment = attr.getPathsegments(i-1);
				EReference previousReference = previousSegment.getRef();
				return MapBasedScope.createScope(IScope.NULLSCOPE, Scopes.scopedElementsFor(previousReference.getEReferenceType().getEAllReferences()));
			} else {
				MetaClass metaClass = EcoreUtil2.getContainerOfType(context, MetaClass.class);
				EClass currentClass = metaClass.getType();
				return MapBasedScope.createScope(IScope.NULLSCOPE, Scopes.scopedElementsFor(currentClass.getEAllReferences()));
			}
		}
		else if (context.eClass()==META_ATTRIBUTE && reference == META_ATTRIBUTE__ATTRIBUTE) {
			MetaClass metaClass = EcoreUtil2.getContainerOfType(context, MetaClass.class);
			EClass currentClass = metaClass.getType();
			MetaAttribute metaAttr = (MetaAttribute) context;
			if (metaAttr.getPathsegmentsLength()>0) {
				MetaAttributePathSegment lastSegment =metaAttr.getPathsegments(metaAttr.getPathsegmentsLength()-1);
				EReference ref = lastSegment.getRef();
				currentClass = ref.getEReferenceType();
			}
//			if (context instanceof MetaAttribute) {
//				((MetaAttribute)context).getPathsegmentsList().
//				for (MetaAttributePathSegment segment : ((MetaAttribute)context).getPathsegmentsList()) {
//					EReference ref = segment.getRef();
//					currentClass = ref.getEReferenceType();
//				}
//			}
			return MapBasedScope.createScope(IScope.NULLSCOPE, Scopes.scopedElementsFor(currentClass.getEAllAttributes()));
		} else if (context.eClass() == TEXT && reference == META_ATTRIBUTE_PATH_SEGMENT__REF) {
			
		}
		return super.getScope(context, reference);
	}
}
