h2. Documentation

This section is about how to fix Problems in the documentation process of Spray. This Problems are most not so significant for the content of this but for the form.

h3. XSL-FO

The problem was that the PDF-documentation wasn't beautiful to look at. So for this we want a title page, header and footer, page-numbering and other little fixes. This sounds quite simple but, the documentation is generated by an "Ant-Process":https://spray.ci.cloudbees.com/view/4.%20Docs/job/spray-docs-build/ws/docs/org.eclipselabs.spray.doc.dev/generate-help-build.xml/*view*/ . So we hadn't changed the sources of this documents (@textile-files@), but rather create additional modifiy-processes and this was the challenge.
Summarized we want to beautify and *modify an existing fo/xml-file*. For this we use "XSL-FO":https://spray.ci.cloudbees.com/view/4.%20Docs/job/spray-docs-build/ws/docs/org.eclipselabs.spray.doc.dev/src/SprayDeveloperGuide.xsl to let the documentation look more modern.

h4. xml/xsl head

We begin with the XSL head-block. The used version is XSL 1.0. Important is that you notice the *namespaces*. You must add them, when you use XSL or if you match a XML block by example.

bc.. 
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xslt="http://www.w3.org/1999/XSL/Format"
  xmlns="http://www.w3.org/1999/XSL/Format"
  xmlns:old="SprayDeveloperGuide.xml"
  xmlns:date="http://exslt.org/dates-and-times"
  exclude-result-prefixes="old date" >
  <xsl:output indent="yes" omit-xml-declaration="yes" />
  <!-- Content here -->
p. 

h4. copy template

*Take care* that the following template must be *at the end* of the "XSL-file":https://spray.ci.cloudbees.com/view/4.%20Docs/job/spray-docs-build/ws/docs/org.eclipselabs.spray.doc.dev/src/SprayDeveloperGuide.xsl in our case.

bc.. 
<!-- Copy template -->
<xsl:template match="node()|@*">
  <xsl:copy>
    <xsl:apply-templates select="node()|@*" />
  </xsl:copy>
</xsl:template>
p. 

This template copies all content into the output. Alternative you could use this for getting the same result:

bc.. 
<!-- Alternative Copy-template -->
<xsl:template match="*">
  <xsl:copy>
    <xsl:copy-of select="attribute::*[.!= '']" />
    <xsl:apply-templates />
  </xsl:copy>
</xsl:template>
p. 

Both templates go over every node in the original and transfer them in the output without modifying. All templates which don't remove a node should be previously this copy-template.

h4. modify root element

Then we want some basically changes like set a default font size. This you must change at @root@-node.

bc.. 
<!-- Modifying the root node with font-attributes -->
<xsl:template match="xslt:root">
  <root font-family="Times" font-size="12pt"
    xmlns="http://www.w3.org/1999/XSL/Format">
    <xsl:apply-templates select="@*|node()" />
  </root>
</xsl:template>
p. 

The template matches only the @root@ element and will be replaced. So we set default font attributes for the document and the rest will be unchanged.

h4. header and footer

We want a header with a horizontal line at the bottom to split it from the content. Also a line in the footer at its top. Additionally the footer should include a page-numbering.
In our "Ant-Process":https://spray.ci.cloudbees.com/view/4.%20Docs/job/spray-docs-build/ws/docs/org.eclipselabs.spray.doc.dev/generate-help-build.xml/*view*/ is an option to generate this, but this doesn't look that good, but we can use this generated footer to replace it with our own header/footer declaration.

bc.. 
<!-- Replace footer with header and new footer declaration -->
<xsl:template match="xslt:region-after">
<!-- header und footer declaration -->
  <region-before extent="2cm" precedence="false"
    region-name="header" />
  <region-after extent="2cm" precedence="false"
    region-name="footer" />
</xsl:template>
p. 

This will be replaced at the top of the output. It gives the regions a name and a size.
Another problem is, that now the header/footer will overlap with the content. For that reason we have to add a margin in the @region-body@ node.

bc.. 
<!-- Add margin top to region body -->
<xsl:template match="xslt:region-body">
  <region-body margin-bottom="3cm" margin-top="2cm" />
</xsl:template>
p. 

Now we have a blank header and a page-number in the footer ("Ant-Process":https://spray.ci.cloudbees.com/view/4.%20Docs/job/spray-docs-build/ws/docs/org.eclipselabs.spray.doc.dev/generate-help-build.xml/*view*/). We take the existing footer to replace it with a header and a new footer definition.

bc.. 
<!-- Replace all footer Elements with Header and new Footer -->
<xsl:template match="xslt:static-content[@flow-name='footer']">
  <!-- Header -->
  <static-content flow-name="header">
    <block font-size="10.0pt" text-align="right">
      <!-- external Graphic with dynamic Source (searching for url of src) -->
      <xsl:element name="external-graphic">
        <xsl:attribute name="src"> ...
      </xsl:element>
    </block>
    <!-- Horizontalline -->
    <block>
      <leader leader-pattern="rule" rule-thickness="1.0pt"
        leader-length="100%" />
    </block>
  </static-content>
  <!-- Footer -->
  <static-content flow-name="footer">
    <block>
      <leader leader-pattern="rule" rule-thickness="1.0pt"
        leader-length="100%" />
    </block>
    <block font-size="10.0pt" text-align="center">
      - <page-number /> -
    </block>
  </static-content>
</xsl:template>

p. 

Here we search for all @static-content@ nodes that have an attribute _flow-name_ with "footer" as text. If a node match we replace it. Here are also the @leader@ nodes which generate a horizontal line with height of 1pt and width of the document. The new page number is now centered and surrounded by "-".
In the header we create a new @external-graphic@ element. This we will see in the next subsection again.

h4. create a modern title-page

For this we want to show the "logo":https://spray.ci.cloudbees.com/view/4.%20Docs/job/spray-docs-build/ws/docs/org.eclipselabs.spray.doc.dev/images/Spray-Logo-C.png of the project first followed by the headline, authors and the current date.

h5. use attribute for another

bc.. 
<!-- Modifying the Titlepage -->
<xsl:template
  match="//xslt:flow/xslt:block/xslt:block[text()='Spray Developer Guide']">

  <!-- Beginning with Logo -->
  <block text-align="center" id="SprayAquickwayofcreatingGraphiti">
    <xsl:element name="external-graphic">
      <xsl:attribute name="src"><xsl:value-of select="//xslt:block/xslt:external-graphic/@src" /></xsl:attribute>
      <xsl:attribute name="width">80%</xsl:attribute>
      <xsl:attribute name="content-height">80%</xsl:attribute>
      <xsl:attribute name="content-width">scale-to-fit</xsl:attribute>
      <xsl:attribute name="scaling">uniform</xsl:attribute>
    </xsl:element>
  </block>
  ...
p. 

We match the block which contains the old title with the text "Spray Developer Guide". There we want our logo which is already implemented in the document but on the wrong place. We will remove this at the next subsection. To get the URL of the logo we search for the _src_-attribute of the originally @external-graphic@. With this information we build a new @external-graphic@ element. We reach this with the @xsl:element@ block. You will only get the wishing effect in combination with the copy-template at the top of this section.

bc.. 
...
<!-- Title -->
<block font-weight="bold" font-size="25pt" text-align="center"
  space-before="19pt">
  Spray Developer Guide
</block>
<!-- Authors -->
<block font-size="14pt" text-align="center" space-before="19pt">Jos
  Warmer, Karsten Thoms, Joerg Reichert
</block>
p. 

The next point of this template is to set the old title followed by a block which contains the authors.

h5. generate dynamic date

bc.. 
<xsl:stylesheet version="1.0"
xmlns:date="http://exslt.org/dates-and-times" ... />
<!-- Dynamic Date in Format DD. MonthName YYYY -->
<block font-weight="italic" font-size="14pt" text-align="center"
    space-before="19pt">
    <xsl:value-of select="date:day-in-month()" />
    .&#160;
    <xsl:value-of select="date:month-name()" />
    &#160;
    <xsl:value-of select="date:year()" />
  </block>
</xsl:template>
p. 

To generate date by XSL dynamic you must include the header like this. With the @xsl:value-of@ element we access the date from namespace. You get non-breakable spaces by adding "&#160;" to your stylesheet, which you can use for formatting. How to remove the old content you don't need anymore, like the logo in the content, you have to see in the 'clean up' subsection.


h4. set hyperlinkstyle

bc.. 
<!-- Underline Hyperlinks -->
<xsl:template match="//xslt:inline[starts-with(text(),'http')]">
  <inline text-decoration="underline" color="blue">
    <xsl:value-of select="."></xsl:value-of>
  </inline>
</xsl:template>
p. 

Here we match all @inline@ elements which text is like 'http...'. We get the content of them with @xsl:value-of@ and the dot as mark for the found node. Then all content will surrounded by a new @inline@ block with other attributes.

h4. add attributes to existing node

bc.. 
<!-- Formatter codeblocks and delete the obsolete parent node -->
<xsl:template match="//xslt:block[@font-family='monospace']">
  <xsl:copy>
    <xsl:copy-of select="@*" />
    <xsl:attribute name="background-color">rgb(246, 244, 240)</xsl:attribute>
    <xsl:attribute name="border-width">1px</xsl:attribute>
    <xsl:attribute name="border-style">solid</xsl:attribute>
    <xsl:attribute name="border-color">rgb(212,212,212)</xsl:attribute>
    <xsl:attribute name="padding">2px</xsl:attribute>
    <xsl:copy-of select="./node()/text()" />
  </xsl:copy>
  <xsl:apply-templates />
</xsl:template>
p. 

In this case we want to mark a block which contains code. So first you match the node you want to modify and you copy the existing attributes with @copy-of@. After this you add new attributes with XSL. In this example you copying text of the child in the modified element which will be deleted later. If you want to apply all content you have to set a '*' instead of './node()/text()'.

h4. forcing page break

If you have a @fo:block@ and want no page-break in the content of this block. For this case you have to choice 1 of the 3 following attributes which you set for the @fo:block@.

bc.. 
<fo:block page-break-inside="avoid"> ...
</fo:block>
p. 

There also
* _page-break-after_
* _page-break-before_

We recommended to use

* _page-break-inside_
Values for this attributes are
* auto - same effect as you won't use this attribute
* always - Force a page break
* avoid - is the best choice. The name says it all.

For more informations you may look "here":http://www.w3.org/TR/xslfo20 .

h4. remove nodes

If you copy your document like in *copy-template* section you may want to remove some nodes. That is quite simple. You match all nodes you don't want to copy *after* the copy template like this.

bc.. 
<!-- copy template -->
...
<!-- Remove unwanted Contents -->
<xsl:template match="//xslt:block[@id='SprayAquickwayofcreatingGraphiti']" />
p. 

In this case all blocks that has an id like this will not been copied.

h4. match node with several properties

bc.. 
<xsl:template match="//xslt:block[@font-family='monospace'][xslt:block[@font-family='monospace'][text()!='']]"> ...
</xsl:template>
p. 

We see a nested template match. Here you get all blocks with the attribute @font-family='monospace'@ *and contains* another block with the same attribute *and* which contains text.

h4. chapter for headers

For this your header should get a @retrieve-marker@, in your "XSL-file":https://spray.ci.cloudbees.com/view/4.%20Docs/job/spray-docs-build/ws/docs/org.eclipselabs.spray.doc.dev/src/SprayDeveloperGuide.xsl, and give it a _retrieve-class-name_ like this.

bc.. 
<retrieve-marker retrieve-class-name="title" retrieve-position="first-starting-within-page" retrieve-boundary="page-sequence" />
p. 

With this properties your header will get a string which is surrounded by a marker named title. "Retrieve-position" is for retrieving the children of an @fo:marker@ attached to an area that is within the containing page and boundary sets how often this will be repeated. 
After we prepared the header we must set a marker to chapter-titles with the same title/name like @retrieve-marker@.

bc.. 
<marker marker-class-name="title"> <!-- insert Chapter here --> </marker> -Chaptername- 
...
p. 

h4. Format table of contents

If you want a table of contents like "1.1 chapter ........... 2", you will need @fo:leader@ and @fo:page-number-citation@.
In our template we match a node with the attribute _internal-destination_ (this is for the bookmarks). This node we modify like you see in the code.

bc.. 
<block text-align-last="justify" margin-left="0em" space-before="5pt">
<xsl:copy>
  <xsl:apply-templates select="node()|@*" />
</xsl:copy>
<leader leader-pattern="dots" leader-pattern-width="5pt" />
<xsl:element name="page-number-citation">
  <xsl:attribute name="ref-id"><xsl:value-of
    select="./@internal-destination" />
  </xsl:attribute>
</xsl:element>
...
</block>
p. 

Really important for this to work is _text-align-last_ in @block@. 
After this you copy the node you've matched and insert a @leader@ element. To see the pagenumber you must create an @page-number-citation@ element. Finally this element get the id of the matched node as an attribute. 

h4. replace in a string

This functionallity is not a default function of XSL version 1.0 like _contains()_. If you want to handle it you have to create a template with a name attribute to call it later. You call a template with @call-template@ and deliver the parameters.

bc.. 
<xsl:variable name="newSrc">
  <xsl:call-template name="string-replace">
    <xsl:with-param name="text"
      select="//xslt:block/xslt:external-graphic/@src[contains(.,'Spray-Logo-C.png)')]" />
    <xsl:with-param name="replace" select="'.png)'" />
    <xsl:with-param name="by" select="'-Big.png)'" />
  </xsl:call-template>
</xsl:variable>
p. 

Our call-template you can see named "string-replace" needs 3 parameters
* _text_ - text which we want to modify
* _replace_ - string in _text_ we want to replace
* _by_ - ... by this string

So in this case we search for an url of the spray-logo and replace the suffix.

bc.. 
<!-- template to replace a string from text -->
<xsl:template name="string-replace-all">
  <xsl:param name="text" />
  <xsl:param name="replace" />
  <xsl:param name="by" />
  <xsl:choose>
    <xsl:when test="contains($text, $replace)">
      <xsl:value-of select="substring-before($text,$replace)" />
      <xsl:value-of select="$by" />
      <xsl:call-template name="string-replace-all">
        <xsl:with-param name="text"
          select="substring-after($text,$replace)" />
        <xsl:with-param name="replace" select="$replace" />
        <xsl:with-param name="by" select="$by" />
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="$text" />
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>
p. 

Here we get the 3 parameters. We can access to the content with "$". After this we open a @choose@ element like if/else in C++. So if _text_ contains _replace_ the template do his thing and call itself recursively in case that there are more strings like that.

h3. Ant-Process

The problem was that you didn't see the @«@-character after generating the documentation files (html, docbook, pdf, eclipse-help) by Ant. The textile files are written in *UTF-8* and that is the clue.
To fix this encoding problem you have to look in the "generate-help-build.xml":https://spray.ci.cloudbees.com/view/4.%20Docs/job/spray-docs-build/ws/docs/org.eclipselabs.spray.doc.dev/generate-help-build.xml of the Ant-process. Here you should add to every @copy@, @concats@, @xslt@, or other nodes in which you work with the textile content, the attribute _encoding="UTF-8"_.

bc.. 
<move file="${content.gen.dir}/${sprayhelp.target.xml.file}" todir="${content.gen.docbook.dir}" encoding="UTF-8" />
p. 

Additional you have to add to all @<wikitext-to-...@-processes a _sourceencoding_-attribute like this:

bc.. 
<wikitext-to-html sourceencoding="UTF-8" formatOutput="true" markupLanguage="${content.source.language}" .../>
p. 

h3. Html Modification

The next step was to style the Html-documentation. The main points for this were the codeblocks, links, table of contents, and the alignment of the site plus the background style. Contents shouldn't change in this case. We use XHTML-1.0-Transitional standard.

h4. codeblocks

We want that the source code snippets will shown as it is and highlight the keywords. Additional the module should be lightweight, simple and support many languages like Java or Html. 
For this we see "google code prettify":https://code.google.com/p/google-code-prettify/ as a good solution. It's a javascript module combing with a "CSS file":https://spray.ci.cloudbees.com/view/4.%20Docs/job/spray-docs-build/ws/docs/org.eclipselabs.spray.doc.dev/src/prettyprintsrc/prettify.css that allows syntax highlighting. Certainly it works with Html and is usable with many browsers like firefox or google-chrome (20. Aug. 2013). The benefit is that you can adjust the module to your style idea or use one of the given themes. The folloring picture shows the default theme with alternating backgroundcolors for the rows and linenumbers for every row. 

!images/htmlprettifyexample.png(Example for syntax)!

To get this linenumbering you must remove @list-style-type@ in prettify.css .

bc.. 
li.L0,li.L1,li.L2,li.L3,li.L5,li.L6,li.L7,li.L8 {
	/* remove this >>>*/ list-style-type: none 
}
p. 

h5. trouble with scriptelement

We download the version dated from 4. Mar. 2013 and include it to the html document with "XSL-File":https://spray.ci.cloudbees.com/view/4.%20Docs/job/spray-docs-build/ws/docs/org.eclipselabs.spray.doc.dev/src/SprayDeveloperGuideModifyHtml.xsl like this:

bc.. 
<xsl:template match="xhtml:head">
	<xsl:copy>
		<link rel="stylesheet" type="text/css" href="style.css">
		</link>
		<link href="prettyprintsrc/prettify.css" type="text/css" rel="stylesheet">
		</link>
		<script src="prettyprintsrc/prettify.js" type="text/javascript">//</script>
		<xsl:apply-templates select="@*|node()" />
	</xsl:copy>
</xsl:template>
p. 

The '//' as content between opening and closing element are important, because XSL will interprete this with no changes. But if you write the script implementation in XSL like this 

bc.. 
<!-- Before in xsl-->
<script src="prettyprintsrc/prettify.js" type="text/javascript"></script>
p. 
And after modification it will be like this in html

bc.. 
<!-- After in Html -->
<script src="prettyprintsrc/prettify.js" type="text/javascript" />
p. 

This is not allowed in html documents with the suffix "html". In this case every tested browser shows only a gray background and no content! So you should give attention to this if you use "XSL-Stylesheet":https://spray.ci.cloudbees.com/view/4.%20Docs/job/spray-docs-build/ws/docs/org.eclipselabs.spray.doc.dev/src/SprayDeveloperGuideModifyHtml.xsl to modify your html/xhtml file. 

h4. CSS

Additional to the prettify.css, there is another costumized css named "style.css":https://spray.ci.cloudbees.com/view/4.%20Docs/job/spray-docs-build/ws/docs/org.eclipselabs.spray.doc.dev/src/style.css . Here you find some summerized tips for css.
First the table of contents (toc) should be highlighted. Here we use a gray inner block witdh rounded borders. 

bc.. 
.toc 
{ ...
  border: 1px solid rgb(225, 225, 225);
  background: none repeat scroll 0% 0% rgb(241, 241, 241);
  border-radius: 9px 9px 9px 9px;  /*Rounded borders*/
}
p. 

The links should be standard for external links in Html and only a little animated by hovering. This is really easy by adding this to your css:

bc.. 
a:HOVER
{ text-decoration: blink; }
p. 

If you adding this arguments to a css class, the containing tags-width will be _min-width < costumcontent-width < max-width_. Additional the content will break if the width is bigger than _max-width_.

bc.. 
min-width: 55em;
max-width: 99%;
display: inline-block;
white-space: pre-wrap;
p. 

h4. Copy to clipboard

The main problem was that if you want to copy content of a prettify code block, you also copy all linenumbers. This effect isn't coming up in Firefox but in all other browsers. So we want a sollution which allows the user to copy the content in a easy way. 
For this we implement the "ZeroClipboard":https://github.com/zeroclipboard/ZeroClipboard project. It allows to include a @div@ tag which is connected to a @javascript@ tag. This will load a flash application which copy the content of a block with an searched id. Also you can say what additional to do in this case, to do an allert by example.
For this you should include "jQuery":http://jquery.com/ firstly and the "ZeroClipboard.js":https://spray.ci.cloudbees.com/view/4.%20Docs/job/spray-docs-build/ws/docs/org.eclipselabs.spray.doc.dev/src/copy2clipboard/ZeroClipboard.js .

bc.. 
<head>
   <script src="copy2clipboard/jquery.js" type="text/javascript">//</script>
   <script src="copy2clipboard/ZeroClipboard.js" type="text/javascript">//</script>
...
p. 

After that we can use the functions. Now you add the @script@ tag with wanted action. You connect this with an id to a @div@ or @button@ tag. In our xsl modification we match every codeblock and add a div with a incrementing number as id and the javascript code.

bc.. 
<xsl:template match="xhtml:pre[xhtml:code]">
		<xsl:variable name="number">
			<xsl:number />
		</xsl:variable>
		<xsl:variable name="clipboardbutton">
			<xsl:text>'#copy2clip_btn</xsl:text>
			<xsl:value-of select="$number"></xsl:value-of>
			<xsl:text>'</xsl:text>
		</xsl:variable>
		<pre class="prettyprint linenums" id="quine {$number}">
			<xsl:value-of select="./xhtml:code" />
		</pre>
		<div id="copy2clip_btn{$number}" data-clipboard-target="quine {$number}"
			title="copy to clipboard." class="copy2clip_btn">
			Clipboard
		</div>
		<xsl:element name="script">
			<xsl:attribute name="language">Javascript</xsl:attribute>
			<xsl:text>
			var clip = new ZeroClipboard( $(
			</xsl:text>
			<xsl:value-of select="$clipboardbutton"></xsl:value-of>
			<xsl:text>
			),{moviePath:
			"./copy2clipboard/ZeroClipboard.swf"} );
			</xsl:text>
		</xsl:element>
	</xsl:template>
p. 

Important for this is to save the current number in a variable and use this to connect the action with our @div@. To get the value of _number_ in the javascript text, we need to another variable which create the string like this @'#copy2clip_btn4'@ . We have to do this with the @xsl:element@ tag, because in this apostrophes the numbervariable will not be interpreted.
This code will generate html like this.

bc.. 
<pre id="quine 4" class="prettyprint linenums"> ... </pre>
<div class="copy2clip_btn" title="copy to clipboard." data-clipboard-target="quine 4" id="copy2clip_btn4">
			Clipboard
		</div>
<script language="Javascript">
	var clip = new ZeroClipboard( $('#copy2clip_btn4'),{moviePath:"./copy2clipboard/ZeroClipboard.swf"} );
</script>
p. 

All ids are references for each other and importent to get the copy action to work. 
