h1. Spray Extensions Guide

h2. Basic extensions: Generation Gap Pattern

h3. Generation Gap Pattern for Java code

The code generated by Spray can be extended (and even fully overwritten) by the developer. For this, Spray uses the Generation Gap Pattern. More specifically we use Conditional Generation 1 (with one gen folder),  as described in "@http://heikobehrens.net/2009/04/23/generation-gap-pattern/@":http://heikobehrens.net/2009/04/23/generation-gap-pattern/ by Heiko Behrens. In  short, the concrete, empty, subclasses that are meant as _extension points_ are generated in the @src-gen/@ folder.  When you want to extend them, you need to move the file to the @src/@ folder. The generator will recognize whether an extension point file is in the @src@ folder and in that case not generate it again. Read Heiko's blog for a more elaborate explanation. The classes that can be extended derive
from classes with the same name with suffix @Base@.

The files generated to the @src-gen/@ folder are furthermore marked as derived within Eclipse. Thus, if you accidently try to edit them, a warning dialog pops up.

!images/extension_1.png!

The Spray UI facilitates this repeating task by adding a context menu action on extension point files. For example, right click on the Feature Provider class:

!images/extension_2.png!

Now choose from the context menu _Spray / Move to source folder for manual extension_:

!images/extension_3.png!

After doing this the class is moved to the @src/@ folder. The derived flag is removed and you can extend the class now.

!images/extension_4.png!

If you accidently moved the file to the @src/@ folder and want to let it be generated again, just remove it. With the next generator run it will appear again in the @src-gen/@ folder.

h3. Generation Gap Pattern for @plugin.xml@

An initial @plugin.xml@ is created into the project root when the Spray project is setup using the Spray project wizard.

h4. Partial regeneration

The generated @plugin.xml@ includes comments like @<!-- DIAGRAM TYPE AUTOGEN START -->@ and @<!-- DIAGRAM TYPE AUTOGEN END -->@ that mark regions as generated. After each save of the *.spray file these regions will be updated. All contents in the @plugin.xml@ that are placed outside those marked regions will stay untouched.

h4. Avoid regeneration

So if you want to use manually written content in favor of the generated one you have to rename (or delete) the marker comments. Its recommended to rename instead of delete the comment as this leaves the option to rename the comment back to be a generation marker comment that will enable over generation again.  

h4. Complete regeneration

If you want the @plugin.xml@ to be completely regenerated you can always delete the @plugin.xml@ in the project root. Then the @plugin.xml@ from the src-gen folder be copied to the project root. You have to perform a refresh on the project to see the copied plugin.xml.  

h2. Extending Spray's code generator

Spray's code generator produces a good basis for Graphiti editors. However, it cannot be complete against user requirements and may contain also bugs. The appliance of the Generation Gap Pattern allows to modify the produced classes and change whatever required. But when the changes need to be applied to all produced classes, it would be more efficient to change the generator's production rules. The naive way to do this would be to change the generator's source directly. This will lead to problems, since Spray's generator implementation will evolve and you would need to merge your changes later and may get lost what actually your changes were.

Spray provides a far more better way to change the generator. Instead of changing the source directly it is possible to derive the existing templates and make Spray use the overridden templates instead of the original ones. Spray uses Xtend, which directly compiles to Java, so the templates themselves can be concerned as just Java classes which you could derive from. 

h3. Create plugin project

To extend the generator you basically need a plugin project. Create one and add the following dependencies:

bc.. 
Require-Bundle: org.eclipse.core.runtime,
 org.eclipselabs.spray.generator.graphiti;bundle-version="0.6.0",
 org.eclipselabs.spray.mm;bundle-version="0.6.0",
 org.eclipselabs.spray.runtime.xtext;bundle-version="0.6.0",
 org.eclipselabs.spray.generator.graphiti.ui
Import-Package: org.eclipse.xtend2.lib,
 org.eclipse.xtext.xbase.lib
p. 

h3. Derive templates

The templates are inside of the plugin @org.eclipselabs.spray.generator.graphiti@, and you will need to know which template(s) you actually need to override. The header comment in the generated code will name the template from which it origins. You likely have to look at the original template source to make good additions.

Derive the template, e.g. 

bc.. 
import org.eclipselabs.spray.generator.graphiti.templates.diagram.FeatureProvider
import org.eclipselabs.spray.mm.spray.Diagram

class FeatureProviderExt extends FeatureProvider { 
    
    override generate_additionalMethods(Diagram context) '''
        // this has been added by a derived template from org.eclipselabs.spray.generator.graphiti.extension
    '''
    
} 
p. 
Most templates (those that generate Java classes) are defining two hook template methods @generate_additionalFields(T)@ and @generate_additionalMethods(T)@ (T is the parameter type, since the templates are parametrized). By default, they are empty, and as their name states, by overriding these methods one could produce additional fields or methods for the generated base class.


h3. Guice Runtime Module

To actually use your derived template class instead of the original one you have to provide a Guice module that binds your class. This looks like follows:

bc.. 
public class GeneratorExtensionRuntimeModule extends AbstractGenericModule {
    public Class<? extends FeatureProvider> bindFeatureProviderTemplate() {
        return FeatureProviderExt.class;
    }
}
p. 

h3. Extension point

Now open the Manifest editor and go to the Extensions section. Add an extension for extension point @org.eclipselabs.spray.runtime.xtext.overridingGuiceModule@. This extension point requires you to provide the class name (property @class@) of your
new Guice module and the class name of the module that you want to override (property @overrides@), which is @org.eclipselabs.spray.generator.graphiti.GraphitiGeneratorModule@.


!images/extension_5.png!

h3. Done!

If you deploy your plugin now (it does not work if the plugin is just in the workspace of the diagram plugin that you are developing, of course) Spray will now recognize your module and override configurations that come from its base implementation. Without touching Spray's sources you are now able to customize the generator templates!

bc.. 
public abstract class MyDiagramFeatureProviderBase extends DefaultFeatureProvider {
  ...
      // this has been added by a derived template from org.eclipselabs.spray.generator.graphiti.extension
}
p. 


